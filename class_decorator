# -*- coding: utf-8 -*-

"""

SRC:   https://tirinox.ru/class-decorator/


Декоратор класса имеет более глубокие возможности по влиянию на класс, он может удалять,
добавлять, менять, переименовывать атрибуты и методы класса.
Он может возвращать совершенно другой класс.
    Старый класс «затирается» и не может быть использован, как базовый класс при полиморфизме

    Декорировать можно любой класс одним и тем же универсальный декоратором,
    а при наследовании – мы ограничены иерархией классов и
    должны считаться с интерфейсами базовых классов.

    Презираются все принципы и ограничения ООП (из-за пунктов 1-3).
----------------------------------------------------------------------

Декораторы классов полезны, чтобы внедриться в класс (иногда незаметно)
и массово воздействовать на его методы и атрибуты.

"""
# =========================================================
#
# =========================================================
import time

# это вспомогательный декоратор будет декорировать каждый метод класса, см. ниже
def timeit(method):
    def timed(*args, **kw):
        ts = time.time()
        result = method(*args, **kw)
        te = time.time()
        delta = (te - ts) * 1000
        print(f'{method.__name__} выполнялся {delta:2.2f} ms')
        return result
    return timed


def timeit_all_methods(cls):
    class NewCls:

        def __init__(self, *args, **kwargs):
            # проксируем полностью создание класса
            # как создали этот NewCls, также создадим и декорируемый класс
            self._obj = cls(*args, **kwargs) # !!!!

        def __getattribute__(self, s):
            print("Debug:", self, s)
            """Он вызывается, когда кто-то пытается обратиться 
            как какому угодно атрибуту (полю, методы и т. п.) класса NewCls"""
            try:
                # папа, у меня есть атрибут s?
                x = super().__getattribute__(s)
            except AttributeError:
                # нет сынок, это не твой атрибут
                print("Debug: except !!!", err)
                pass
            else:
                # да сынок, это твое  : (атрибут класса декоратора)
                print("Debug:   x->", x, s)  # Foo
                return x

            # объект, значит у тебя должен быть атрибут s
            attr = self._obj.__getattribute__(s)

            # метод ли он?
            if isinstance(attr, type(self.__init__)):
                # И проверим его тип, сравним его с типом любого метода
                # да, обернуть его в измеритель времени
                return timeit(attr)
            else:
                # не метод, что-то другое
                return attr
    #   -------------------------------------------------
    return NewCls


@timeit_all_methods
class Foo:
    def a(self):
        print("метод a начался")
        time.sleep(0.777)
        print("метод a кончился")
        print("INFO", self.__class__.__name__) # Foo
        print("INFO", self) # Foo

"""
Декоратор timeit_all_methods содержит в себе определение нового класса NewCls 
и возвращает его вместо оригинального класса. Т.е. класс Foo – это уже не Foo, а NewCls.

"""
# =========================================================
#
# =========================================================
f = Foo()
f.a()

# метод a начался
# метод a кончился
# a выполнялся 787.45 ms
